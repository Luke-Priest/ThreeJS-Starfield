<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <style>
            body {
                margin: 0;
            }
            canvas {
                width: 100%;
                height: 100%; 
            }
        </style>
    </head>
    <body>
        <script type="importmap">
            {
              "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/", "getFresnelMat": "https://pub-48b3469761b74fb6b133ca09b23955ea.r2.dev/getFresnelMat.js"
              }
            }
            </script>
        <script type="module">
            import * as THREE from 'three';
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
            import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
            import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
            import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
            import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
            import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
            import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
            import Stats from 'three/addons/libs/stats.module.js';
            import { getFresnelMat } from "getFresnelMat";
            
            let camera, scene, renderer, composer, earth, earthCloud, textMesh, stats, moon, mercury, venus, venusAtmosphere, mars, oldPlanetPosX, oldPlanetPosZ, newPlanetPosX, newPlanetPosZ, planetDifX, planetDifZ, gui, conf, sun, planet, light;

            let controls;

            conf = {
                    sun: function() {goToSun()},
                    mercury: function() {goToMercury()},
                    venus: function() {goToVenus()},
                    earth: function() {goToEarth()},
                    moon: function() {goToMoon()},
                    mars: function() {goToMars()},
                }

            const mercuryRotDiameter = 2*(57000+695.7);
            const venusRotDiameter = 2*(108000+695.7);
            const earthRotDiameter = 2*(149600+695.7);
            const moonRotDiameter = 38.4400*2;
            const marsRotDiameter = 2*(149600+695.7);
            const center = new THREE.Vector3(0, 0, 0);

            // Step 5: In the animation loop, update the mesh's position using polar coordinates
            let angle = 0;

            const earthGroup = new THREE.Group();
            const venusGroup = new THREE.Group();


            // Create a new instance of THREE.Clock()
            var clock = new THREE.Clock();

            // Delta time used for smooth movement
            var delta = 0;

            function init() {
                // Init scene
                scene = new THREE.Scene();

                // Init camera (PerspectiveCamera)
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    999999999999
                );

                camera.position.set(1,1,1);

                // Init renderer
                renderer = new THREE.WebGLRenderer({});
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Set size (whole window)
                renderer.setSize(window.innerWidth, window.innerHeight);

                // Render to canvas element
                document.body.appendChild(renderer.domElement);

                controls = new OrbitControls( camera, renderer.domElement );
                
                gui = new GUI();
                gui.add( conf, 'sun').name( 'Sun' );
                gui.add( conf, 'mercury').name( 'Mercury' );
                gui.add( conf, 'venus').name( 'Venus' );
                gui.add( conf, 'earth').name( 'Earth' );
                gui.add( conf, 'moon').name( 'Moon' );
                gui.add( conf, 'mars').name( 'Mars' );
                gui.open();

                // Create Sun
                const sunGeo = new THREE.SphereGeometry(695.7, 32, 32); // r= 695,700 
                    const sun = new THREE.Mesh(sunGeo);
                    scene.add( sun );
                    light = new THREE.PointLight( 0xffffff );
                    light.power = 4000000000000; 
                    light.distance = 69630000;
                    light.castShadow = true;
                    scene.add( light );
                    //Set up shadow properties for the light
                    light.shadow.mapSize.width = 8046; 
                    light.shadow.mapSize.height = 8046;
                    light.shadow.radius = 6;
                    light.shadow.camera.near = 0.5; 
                    light.shadow.camera.far = 500; 

                    const pointLightHelper = new THREE.PointLightHelper( light );

                //Create Mecury
                const mercuryGeometry = new THREE.SphereGeometry(2.4405, 64, 64); // r= 2,440.5 km
                const mercuryTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/ThreeJS-Starfield/Test/textures/2k_mercury.jpg');
                const mercuryMaterial = new THREE.MeshPhongMaterial({
                    map: mercuryTexture,
                })
                mercury = new THREE.Mesh(mercuryGeometry, mercuryMaterial);
                scene.add(mercury);

                //Create Venus

                scene.add(venusGroup);

                const venusGeometry = new THREE.SphereGeometry(6.0518, 64, 64); // r= 6,051.8 km 
                const venusTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/ThreeJS-Starfield/Test/textures/2k_venus_surface.jpg');
                const venusMaterial = new THREE.MeshPhongMaterial({
                    map: venusTexture,
                });
                venus = new THREE.Mesh(venusGeometry, venusMaterial);
                venusGroup.add(venus);

                const venusAtmosphereGeometry = new THREE.SphereGeometry(6.2, 64, 64);
                const venusAtmosphereTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/ThreeJS-Starfield/Test/textures/2k_venus_atmosphere.jpg');
                const venusAtmosphereMaterial = new THREE.MeshPhongMaterial({
                    map: venusAtmosphereTexture,
                    transparent: true,
                    opacity: 0.9,
                })
                venusAtmosphere = new THREE.Mesh(venusAtmosphereGeometry, venusAtmosphereMaterial);
                venusGroup.add(venusAtmosphere);

                //Create Earth
                    
                    scene.add(earthGroup);

                    const earthGeometry = new THREE.SphereGeometry(6.371, 64, 64); // r= 6371 km
                    const texture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/2024-2025-Portfolio/main/textures/RealisticDayEarth.jpg'); 
                    const bumpMap = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/2024-2025-Portfolio/main/textures/earthbump10k.jpg');
                    const specularMap = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/2024-2025-Portfolio/main/textures/water_4k.png');
                    const lightMap = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/2024-2025-Portfolio/main/textures/EarthLightMap.jpg');
                    const earthMaterial = new THREE.MeshPhongMaterial({ 
                        map: texture,
                        bumpMap: bumpMap,
                        bumpScale: 10,
                        specularMap: specularMap,
                        specular: new THREE.Color('grey'),
                        shininess: 20,
                        emissiveMap: lightMap,
                        emissive: 0xf5e9b9,
                        emissiveIntensity: 0.2,
                    });

                    // Create earth mesh with geo and material
                    earth = new THREE.Mesh(earthGeometry, earthMaterial);
                    earth.castShadow = true;
                    earth.receiveShadow = true; 
                    earthGroup.add(earth);

                    //Create clouds
                    const cloudGeometry = new THREE.SphereGeometry(6.39, 64, 64); // Should be optimized // to scale r=6390 km
                    const cloudTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/2024-2025-Portfolio/main/textures/fair_clouds_4k.png'); // Might wanna change texture for more clouds
                    const cloudMaterial = new THREE.MeshPhongMaterial({
                        map: cloudTexture,
                        transparent: true,
                    });

                    // Create cloud mesh with geo and material
                    earthCloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    earthCloud.receiveShadow = true; //default is false
                    earthGroup.add(earthCloud);

                    // Fresnel Shader
                    const fresnelMat = getFresnelMat();
                    const glowMesh = new THREE.Mesh(earthGeometry, fresnelMat);
                    glowMesh.scale.setScalar(1.008);
                    earthGroup.add(glowMesh);

                // Create Moon 
                    const moonGeo = new THREE.SphereGeometry(1.7375, 32, 32); // r= 1,737.5 km
                    const moonTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Scuwub/2024-2025-Portfolio/Test/textures/2k_moon.jpg');
                    const moonMat = new THREE.MeshPhongMaterial({
                        emissive: true,
                        map: moonTexture,
                    });
                    moon = new THREE.Mesh(moonGeo, moonMat);
                    scene.add(moon);
                    moon.castShadow = true;
                    moon.receiveShadow = true; 

                // Create Mars
                    const marsGeo = new THREE.SphereGeometry(100, 64, 64);
                    //const marsTexture = new THREE.TextureLoader().load('');
                    //const marsMat = new THREE.MeshPhongMaterial({
                    //    map: marsTexture,
                    //});
                    mars = new THREE.Mesh(marsGeo);
                    scene.add(mars);

                stats = new Stats();
				document.body.appendChild( stats.dom );

                planet = sun;

                camera.position.set(9999,0,0);

                //postprocessing
                composer = new EffectComposer(renderer);
                composer.addPass(new RenderPass(scene, camera));
                composer.addPass(new UnrealBloomPass({x: 1024, y: 1024}, 0.35, 0.0, 0.75) );
                composer.addPass(new SSAOPass(scene, camera));
                composer.addPass( new SMAAPass( window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio() ) );  
                composer.addPass( new OutputPass() ); 

                }

            //Find and orbit the Sun
            function goToSun() {
                planet = sun;
                controls.target.set(0,0,0);
                camera.position.x = 9999;
                camera.position.y = 0;
                camera.position.z = 0;
            }
            
            //Find and orbit Mercury
            function goToMercury() {
                planet = mercury;
                light.power = 400000000000; //Change how bright the sun is because I don't know how to change the exposure of the camera
                controls.target = planet.position;
                camera.position.x = planet.position.x + 20;
                camera.position.y = planet.position.y;
                camera.position.z = planet.position.z;
            }

            //Find and orbit Venus
            function goToVenus() {
                planet = venusGroup;
                light.power = 1500000000000; //Change how bright the sun is because I don't know how to change the exposure of the camera
                controls.target = planet.position;
                camera.position.x = planet.position.x + 30;
                camera.position.y = planet.position.y;
                camera.position.z = planet.position.z;
            }

            // Find and orbit the Earth
            function goToEarth() {
                planet = earthGroup;
                light.power = 4000000000000; //Change how bright the sun is because I don't know how to change the exposure of the camera
                controls.target = planet.position;
                camera.position.x = planet.position.x + 15;
                camera.position.y = planet.position.y;
                camera.position.z = planet.position.z;
            }

            // Find and Orbit Earth's moon
            function goToMoon() {
                planet = moon;
                light.power = 4000000000000; //Change how bright the sun is because I don't know how to change the exposure of the camera
                controls.target = planet.position;
                camera.position.x = planet.position.x + 15;
                camera.position.y = planet.position.y;
                camera.position.z = planet.position.z;
            }

            // Find and Orbit Mars
            function goToMars() {
                planet = mars;
                light.power = 4000000000000; //Change how bright the sun is because I don't know how to change the exposure of the camera
                controls.target = planet.position;
                camera.position.x = planet.position.x + 15;
                camera.position.y = planet.position.y;
                camera.position.z = planet.position.z;
            }

            // 5-27 Weird bug that spits errors and when switched to from another planet after the user move the camera, camera points away from the Sun

            // Draw the scene every time the screen is refreshed
            function animate() {
                requestAnimationFrame(animate);
                composer.render();
                delta = clock.getDelta();
                 // Step 4: Define the angle increment
                const angleIncrement = Math.PI / -10 * delta; //-150
                // Prerotation calcs
                    oldPlanetPosX = planet.position.x;
                    oldPlanetPosZ = planet.position.z;
                // Mercury Rotations
                    mercury.position.x = center.x + mercuryRotDiameter * Math.cos(angle);
                    mercury.position.z = center.z + mercuryRotDiameter * Math.sin(angle);
                // Venus Rotations
                    venusGroup.position.x = center.x + venusRotDiameter * Math.cos(angle);
                    venusGroup.position.z = center.z + venusRotDiameter * Math.sin(angle);
                    venusAtmosphere.rotation.y += 0.03 * delta;
                // Earth Rotations
                    earthGroup.position.x = center.x + earthRotDiameter * Math.cos(angle);
                    earthGroup.position.z = center.z + earthRotDiameter * Math.sin(angle);
                    earth.rotation.y += 0.02 * delta;
                    earthCloud.rotation.y += 0.03 * delta;
                // Moon Rotations
                    moon.position.x = earthGroup.position.x + moonRotDiameter * Math.cos(angle);
                    moon.position.z = earthGroup.position.z + moonRotDiameter * Math.sin(angle);
                // Mars Rotations
                    mars.position.x = center.x + marsRotDiameter * Math.cos(angle);
                    mars.position.z = center.z + marsRotDiameter * Math.sin(angle);
                // Camera Rotations
                    newPlanetPosX = planet.position.x;
                    newPlanetPosZ = planet.position.z;
                    planetDifX = oldPlanetPosX - newPlanetPosX; 
                    planetDifZ = oldPlanetPosZ - newPlanetPosZ; 
                    camera.position.x = camera.position.x - planetDifX;
                    camera.position.z = camera.position.z - planetDifZ;
                    controls.target = planet.position;
                    controls.update();
                    angle += angleIncrement;
                stats.update();
            }

            function onWindowResize() {
                // Camera frustum aspect ratio
                camera.aspect = window.innerWidth / window.innerHeight;
                // After making changes to aspect
                camera.updateProjectionMatrix();
                // Reset size
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            }

            window.addEventListener('resize', onWindowResize, false);

            init();
            onWindowResize();
            animate();

        </script>
    </body>
</html>